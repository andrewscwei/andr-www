{
  "id": "V34VdyEAACEATyi4",
  "uid": "the-shunting-yard-algorithm",
  "url": null,
  "type": "log",
  "href": "https://andr-mu.cdn.prismic.io/api/v2/documents/search?ref=ZwSajRAAACIA6x5O&q=%5B%5B%3Ad+%3D+at%28document.id%2C+%22V34VdyEAACEATyi4%22%29+%5D%5D",
  "tags": [
    "algorithms",
    "coding",
    "objc",
    "math"
  ],
  "first_publication_date": null,
  "last_publication_date": "2017-08-31T02:10:35+0000",
  "slugs": [
    "the-shunting-yard-algorithm"
  ],
  "linked_documents": [],
  "lang": "en-us",
  "alternate_languages": [],
  "data": {
    "title": [
      {
        "type": "heading1",
        "text": "The Shunting-Yard Algorithm",
        "spans": []
      }
    ],
    "synopsis": [],
    "cover": {
      "dimensions": {
        "width": 1920,
        "height": 1080
      },
      "alt": null,
      "copyright": null,
      "url": "https://images.prismic.io/andr-mu/f64da2ad55d6b411c30c016d6de545a52f6a072b_shunting-yard-cover.jpg?auto=compress,format",
      "id": "V34VPyEAAB0ATydh",
      "edit": {
        "x": 0,
        "y": -133,
        "zoom": 1.2,
        "background": "#fff"
      }
    },
    "markdown": [
      {
        "type": "preformatted",
        "text": "The *Shunting-Yard* algorithm is an algorithm developed by [Edsger Dijkstra](http://en.wikipedia.org/wiki/Edsger_Dijkstra) which parses infix mathematical expressions into *Reverse Polish Notations* (RPN). The algorithm scans a string representation of a math expression (i.e. `1+4(6)+53`) and records each character group in the expression as tokens, and each token will be processed accordingly to generate an RPN stack. From the RPN output the numerical answer can then be easily deducted.\n\n## Requirements\n\n1.  A temporary stack array for storing math operator tokens inside the math expression. Let this be `stack`.\n2.  An output array. This will eventually be the final RPN output. Let this be `output`.\n3.  Both arrays implement the stack data structure.\n\n\n## Terms Used\n\n1.  **Operand**: a fixed numerical value of some sort (i.e. a number, a constant like `π`, or an `ANS` in a calculator).\n2.  **Unary Postfix Operator**: operators that appear *after* an operand and only require one operand to operate (i.e. `!`, `%`).\n3.  **Unary Prefix Operator**: operators that appear *before* an operand and only require one operand to operate (i.e. `√`, `-`).\n4.  **Function**: math functions like `sin`, `cos`, and `tan` that take in at least 1 parameter. In this context, only functions that take in exactly 1 parameter are considered.\n\n## Walkthrough\n\n1.  Given a string mathematical expression, from left to right, scan for each `token`.\n    1.  If `token` is an *operand*, push it onto `output`.\n    2.  If `token` is a *unary postfix operator*, push it onto `output`.\n    3.  If `token` is a *unary prefix operator*, push it onto `stack`.\n    4.  If `token` is a *function*, push it onto `stack`.\n    5.  If `token` is an *operator*:\n        1.  If operator is *left-associative* (i.e. `+`, `-`, `*`, `/`):\n            -   While `stack` contains an operator that has equal/higher precedence than `token`, pop `stack` and push the popped item onto `output`.\n            -   Push `token` onto `stack`.\n        2.  If operator is *right-associative* (i.e. `^`, `EE`, `√`, `-`):\n            - While `stack` contains an operator that has higher precedence than `token`, pop `stack` and push popped item onto `output`.\n            - Push `token` onto `stack`.\n    6.  If `token` is a *parenthesis*:\n        1.  If *left-parenthesis* `(`:\n            - Push `token` onto `stack`.\n        2.  If *right-parenthesis* `)`:\n            - While top of `stack` is not a *left-parenthesis*, pop each item from `stack` and push each popped item onto `output`.\n            - Now pop `stack` one more time (popped item should be a *left-parenthesis*).\n            - If top of `stack` is now a *function*, pop that as well and push it onto `output`.\n2.  Pop remainder of `stack` and push each popped item onto `output`.\n3.  `output` now represents a postfix math notation, or RPN. `stack` should now be empty and can be deleted from memory.\n\n## Example\n\nConsider the math expression: `1 + 3 * 9 / (2 + 4)`\n\n1.  First `token` is `1` which is an operand, push it onto `output`.\n\n    ```\n    $ output = [\"1\"]\n    $ stack = []\n    ```\n\n2.  Next `token` is `+` - apply above rules, this goes straight onto `stack`.\n\n    ```\n    $ output = [\"1\"]\n    $ stack = [\"+\"]\n    ```\n\n3.  Next `token` is `3` - goes onto `output`.\n\n    ```\n    $ output = [\"1\", \"3\"]\n    $ stack = [\"+\"]\n    ```\n\n4.  Next `token` is `*` - following the above rules, the only operator in the stack is `+` which is of lower precedence, so push `*` straight onto `stack`.\n\n    ```\n    $ output = [\"1\", \"3}]\n    $ stack = [\"+\", \"*}]\n    ```\n\n5.  Next `token` is `9` - to `output`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9}]\n    $ stack = [\"+\", \"*}]\n    ```\n\n6.  Next `token` is `/` - `stack` contains `*` which is of equal precedence. Pop and push that onto `output`, and push `/` onto `stack`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9\", \"*}]\n    $ stack = [\"+\", \"/}]\n    ```\n\n7.  Next `token` is a left-parenthesis - goes straight to `stack`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9\", \"*}]\n    $ stack = [\"+\", \"/\", \"(}]\n    ```\n\n8.  Next `token` is `2` - to `output`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9\", \"*\", \"2}]\n    $ stack = [\"+\", \"/\", \"(}]\n    ```\n\n7.  Next `token` is `+` - apply above rules, top of `stack` is `(`, NOT an operator, so ignore and push `+` straight onto `stack`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9\", \"*\", \"2}]\n    $ stack = [\"+\", \"/\", \"(\", \"+}]\n    ```\n\n8.  Next `token` is `4` - to `output`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9\", \"*\", \"2\", \"4}]\n    $ stack = [\"+\", \"/\", \"(\", \"+}]\n    ```\n\n9.  Last `token` is a right-parenthesis - pop and push everything on the `stack` onto `output` until `(` is reached. Then pop `(`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9\", \"*\", \"2\", \"4\", \"+}]\n    $ stack = [\"+\", \"/}]\n    ```\n\n\n10. No more tokens, so pop remaining items from `stack` and push them onto `output`.\n\n    ```\n    $ output = [\"1\", \"3\", \"9\", \"*\", \"2\", \"4\", \"+\", \"/\", \"+}]\n    $ stack = []\n    ```\n\nFinal `output` `[\"1\", \"3\", \"9\", \"*\", \"2\", \"4\", \"+\", \"/\", \"+\"]` is now RPN.\n\n\n## Implementation\n\nAfter understanding the concept behind the *Shunting-Yard* algorithm, implementation should be trivial. However, this is assuming that the tokens are properly recorded from a string-based math expression, and that a method for evaluating RPN stacks is available. The algorithm can be further extended to consider other token variations such as expressions like `2(6)` and `(6)(2)` which both mean `2*6`.",
        "spans": []
      }
    ],
    "date": "2011-10-09",
    "mathjax": null,
    "prism": "Yes"
  }
}
